<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Summary Assistant</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- PropTypes (for react-dropzone dependency) -->
    <script src="https://unpkg.com/prop-types@15.7.2/prop-types.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;
    </script>
    <!-- Tesseract.js -->
    <script src='https://unpkg.com/tesseract.js@2.1.0/dist/tesseract.min.js'></script>
    <!-- React Dropzone (using a UMD build) -->
    <script src="https://unpkg.com/react-dropzone@11.3.4/dist/index.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback } = React;
        const { useDropzone } = window.reactDropzone;

        const App = () => {
            const [file, setFile] = useState(null);
            const [summary, setSummary] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState('');
            const [summaryLength, setSummaryLength] = useState('medium');
            const [progress, setProgress] = useState(0);
            const [extractedText, setExtractedText] = useState('');

            const onDrop = useCallback(acceptedFiles => {
                const selectedFile = acceptedFiles[0];
                if (selectedFile && (selectedFile.type === 'application/pdf' || selectedFile.type.startsWith('image/'))) {
                    setFile(selectedFile);
                    setError('');
                    setSummary([]);
                    setExtractedText('');
                } else {
                    setError('Please upload a valid PDF or image file.');
                    setFile(null);
                }
            }, []);

            const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop, accept: 'application/pdf,image/*' });

            const extractText = async () => {
                if (!file) return '';
                
                setProgress(0);

                if (file.type === 'application/pdf') {
                    const reader = new FileReader();
                    return new Promise((resolve, reject) => {
                        reader.onload = async (event) => {
                            try {
                                const typedArray = new Uint8Array(event.target.result);
                                const pdf = await pdfjsLib.getDocument(typedArray).promise;
                                let fullText = '';
                                for (let i = 1; i <= pdf.numPages; i++) {
                                    const page = await pdf.getPage(i);
                                    const content = await page.getTextContent();
                                    
                                    const items = content.items.slice();
                                    let lines = [];
                                    let currentLine = [];
                                    let lastY = -1;

                                    for (const item of items) {
                                        if (item.str.trim() === '') continue;
                                        if (lastY !== -1 && Math.abs(item.transform[5] - lastY) > 5) {
                                            currentLine.sort((a,b) => a.transform[4] - b.transform[4]);
                                            lines.push(currentLine.map(i => i.str).join(' '));
                                            currentLine = [item];
                                        } else {
                                            currentLine.push(item);
                                        }
                                        lastY = item.transform[5];
                                    }
                                    if (currentLine.length > 0) {
                                        currentLine.sort((a,b) => a.transform[4] - b.transform[4]);
                                        lines.push(currentLine.map(i => i.str).join(' '));
                                    }
                                    
                                    fullText += lines.join('\n');
                                    if (i < pdf.numPages) {
                                        fullText += '\n\n--- Page Break ---\n\n';
                                    }
                                    setProgress(Math.round((i / pdf.numPages) * 100));
                                }
                                resolve(fullText);
                            } catch (e) {
                                console.error(e);
                                reject('Error parsing PDF file.');
                            }
                        };
                        reader.onerror = () => reject('Error reading file.');
                        reader.readAsArrayBuffer(file);
                    });
                } else if (file.type.startsWith('image/')) {
                    const { data: { text } } = await Tesseract.recognize(file, 'eng', {
                        logger: m => {
                           if (m.status === 'recognizing text') {
                               setProgress(Math.round(m.progress * 100));
                           }
                        }
                    });
                    return text;
                }
                return '';
            };

            const generateSimpleSummary = (text, length) => {
                if (!text) return [];
                const stopWords = new Set(['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself', 'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will', 'just', 'don', 'should', 'now']);
                const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
                if (sentences.length <= 1) return [text];
                const wordFrequencies = {};
                const words = text.toLowerCase().replace(/[^a-zA-Z\s]/g, '').split(/\s+/);
                words.forEach(word => {
                    if (!stopWords.has(word)) {
                        wordFrequencies[word] = (wordFrequencies[word] || 0) + 1;
                    }
                });
                const sentenceScores = {};
                sentences.forEach((sentence, index) => {
                    let score = 0;
                    const sentenceWords = sentence.toLowerCase().replace(/[^a-zA-Z\s]/g, '').split(/\s+/);
                    sentenceWords.forEach(word => {
                        if (wordFrequencies[word]) {
                            score += wordFrequencies[word];
                        }
                    });
                     if (sentenceWords.length > 0) {
                        sentenceScores[index] = score / sentenceWords.length;
                    } else {
                        sentenceScores[index] = 0;
                    }
                });
                const rankedSentences = sentences
                    .map((sentence, index) => ({ sentence, index, score: sentenceScores[index] || 0 }))
                    .sort((a, b) => b.score - a.score);
                let numSentences;
                switch (length) {
                    case 'short':
                        numSentences = Math.max(1, Math.floor(sentences.length * 0.2));
                        break;
                    case 'long':
                        numSentences = Math.max(3, Math.floor(sentences.length * 0.6));
                        break;
                    case 'medium':
                    default:
                        numSentences = Math.max(2, Math.floor(sentences.length * 0.4));
                        break;
                }
                numSentences = Math.min(numSentences, rankedSentences.length);
                const topSentences = rankedSentences.slice(0, numSentences)
                    .sort((a, b) => a.index - b.index);
                return topSentences.map(item => item.sentence.trim());
            };
            
            const handleExtractText = async () => {
                if (!file) {
                    setError('Please upload a file first.');
                    return;
                }
                setIsLoading(true);
                setError('');
                setSummary([]);
                setExtractedText('');
                try {
                    const text = await extractText();
                    if (!text) {
                        throw new Error('Could not extract text from the file.');
                    }
                    setExtractedText(text);
                } catch (e) {
                    setError(e.message || 'An unexpected error occurred.');
                } finally {
                    setIsLoading(false);
                    setProgress(0);
                }
            };
            
            const handleGenerateSummary = () => {
                if (!extractedText) {
                    setError('Please extract text from a file first.');
                    return;
                }
                const summaryPoints = generateSimpleSummary(extractedText, summaryLength);
                if (!summaryPoints || summaryPoints.length === 0) {
                     setError('Could not generate summary from the document.');
                } else {
                    setSummary(summaryPoints);
                }
            };

            return (
                <div className="min-h-screen bg-indigo-50 text-gray-800 font-sans flex items-center justify-center p-4">
                    <div className="w-full max-w-2xl bg-white shadow-2xl shadow-indigo-200/50 rounded-2xl p-8 space-y-8">
                        <header className="text-center">
                            <h1 className="text-4xl font-bold text-indigo-800">Document Summary Assistant</h1>
                            <p className="text-lg text-indigo-600 mt-2">Upload a file, view its text, and get a smart summary.</p>
                        </header>

                        <main className="space-y-6">
                            {!extractedText && (
                                <>
                                    <div {...getRootProps()} className={`p-10 border-2 border-dashed rounded-xl text-center cursor-pointer transition-colors ${isDragActive ? 'border-indigo-500 bg-indigo-100' : 'border-indigo-200 hover:border-indigo-400'}`}>
                                        <input {...getInputProps()} />
                                        {file ? (
                                        <p className="text-indigo-700">Selected file: <span className="font-semibold">{file.name}</span></p>
                                        ) : (
                                        <p className="text-indigo-500">{isDragActive ? 'Drop the files here...' : 'Drag & drop a file here, or click to select a file'}</p>
                                        )}
                                    </div>
                                    <button
                                        onClick={handleExtractText}
                                        disabled={!file || isLoading}
                                        className="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 disabled:bg-indigo-300 transition-all duration-300 ease-in-out transform hover:scale-105 disabled:scale-100"
                                    >
                                        {isLoading ? 'Extracting...' : 'Extract & View Text'}
                                    </button>
                                </>
                            )}
                            
                            {error && <p className="text-red-500 text-center bg-red-50 p-3 rounded-lg">{error}</p>}

                            {isLoading && (
                                <div className="w-full bg-indigo-200 rounded-full h-2.5">
                                    <div className="bg-indigo-600 h-2.5 rounded-full" style={{ width: `${progress}%`, transition: 'width 0.3s ease-in-out' }}></div>
                                </div>
                            )}

                            {extractedText && !isLoading && (
                                <div className="space-y-6">
                                    <div className="p-6 bg-indigo-50 rounded-xl shadow-inner space-y-4">
                                        <h2 className="text-2xl font-semibold text-indigo-800">Text-O-Vision: Full Extracted Text</h2>
                                        <pre className="text-indigo-800 whitespace-pre-wrap leading-relaxed font-sans bg-white p-4 rounded-lg border border-indigo-200 max-h-96 overflow-y-auto">
                                            {extractedText}
                                        </pre>
                                    </div>
                                    
                                    <div className="p-6 bg-indigo-50 rounded-xl shadow-inner space-y-6">
                                        <h2 className="text-2xl font-semibold text-indigo-800 text-center">Generate Summary</h2>
                                        <div className="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-6">
                                            <p className="font-medium text-indigo-700">Summary Length:</p>
                                            <div className="flex items-center space-x-4">
                                            {['short', 'medium', 'long'].map(len => (
                                                <label key={len} className="flex items-center space-x-2 cursor-pointer">
                                                <input
                                                    type="radio"
                                                    name="summaryLength"
                                                    value={len}
                                                    checked={summaryLength === len}
                                                    onChange={(e) => setSummaryLength(e.target.value)}
                                                    className="form-radio h-4 w-4 text-indigo-600 transition duration-150 ease-in-out"
                                                />
                                                <span className="capitalize text-indigo-700">{len}</span>
                                                </label>
                                            ))}
                                            </div>
                                        </div>
                                         <button
                                            onClick={handleGenerateSummary}
                                            className="w-full bg-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-4 focus:ring-purple-300 transition-all duration-300 ease-in-out transform hover:scale-105"
                                        >
                                            Generate Summary
                                        </button>
                                    </div>
                                </div>
                            )}

                            {summary.length > 0 && !isLoading && (
                                <div className="p-6 bg-purple-50 rounded-xl shadow-inner space-y-4">
                                    <h2 className="text-2xl font-semibold text-purple-800">Summary:</h2>
                                    <ul className="list-disc list-inside space-y-2 text-purple-700">
                                        {summary.map((point, index) => (
                                            <li key={index} className="leading-relaxed">{point}</li>
                                        ))}
                                    </ul>
                                </div>
                            )}
                        </main>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>

